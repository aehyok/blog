import{_ as e,c as l,o as i,ag as n}from"./chunks/framework.mJdS8VI0.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"article/code/2022-11-24-项目上线.md","filePath":"article/code/2022-11-24-项目上线.md","lastUpdated":1750931050000}'),t={name:"article/code/2022-11-24-项目上线.md"};function s(r,a,o,h,p,d){return i(),l("div",null,a[0]||(a[0]=[n(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>最近正在做的项目上线了，问题很多，有前端的问题也有后端的问题。这里就简单的总结一下。</p><h2 id="前端" tabindex="-1">前端 <a class="header-anchor" href="#前端" aria-label="Permalink to &quot;前端&quot;">​</a></h2><p>先说一下前端的问题，这里对代码的探讨不做过多的展示，主要简单说明一下技术的实现方案。</p><h4 id="技术选型问题" tabindex="-1">技术选型问题 <a class="header-anchor" href="#技术选型问题" aria-label="Permalink to &quot;技术选型问题&quot;">​</a></h4><p>h5嵌套到小程序的webview,但是又要用到小程序里的地图定位，就需要由H5跳转到小程序的页面，然后要由小程序页面返回到webview中的h5,这里还需要有一个返回值传到h5中，这里我暂时没想到办法，至少我没想到办法回传数据，于是只能简单的写个定时器，不断的通过接口调用，相当于数据的回传刷新了。</p><p>这里如果完全是小程序的页面就不会存在这个问题了，不过水饺咱没时间全部用小程序的页面呢？</p><h4 id="表单重复提交问题" tabindex="-1">表单重复提交问题 <a class="header-anchor" href="#表单重复提交问题" aria-label="Permalink to &quot;表单重复提交问题&quot;">​</a></h4><p>由于项目中主要的就是数据的录入，所以出问题最多的就是在表单多次提交，其实也有很多的方法。</p><ul><li>方法一： 按钮提交时，将按钮设置为加载状态，并不可点击。</li><li>方法二： 通过pinia保存状态数据，点击保存时对比数据，数据如果未被修改，则不调用接口保存，有效的减少了服务器写入数据的压力。</li></ul><h4 id="缓存问题" tabindex="-1">缓存问题 <a class="header-anchor" href="#缓存问题" aria-label="Permalink to &quot;缓存问题&quot;">​</a></h4><p>由于是h5嵌套到webView的小程序中的，所以有时候明明更新了前端，用户却还是之前的版本，这里想到的办法就是通过nginx 配置 缓存</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>location /{</span></span>
<span class="line"><span>    alias /usr/local/xxxx;</span></span>
<span class="line"><span>    index index.html;</span></span>
<span class="line"><span>    add_header Cache-Control no-cache;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>no-cache 协商缓存，每次也去服务器请求，但会进行判断是否是新的资源，如果是旧的资源，则直接返回304使用客户端的缓存。</p><p>no-store 相当于每次请求都会从服务器获取前端页面，不会进行缓存。</p><h4 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h4><p>当然还存在其他一些小问题，比如用户操作便利性的改进，以及友好的错误提示 等等。</p><h2 id="后端" tabindex="-1">后端 <a class="header-anchor" href="#后端" aria-label="Permalink to &quot;后端&quot;">​</a></h2><p>由于我也参与了一些后端接口的工作，对整个前后端的情况都有所了解。</p><h4 id="重复数据" tabindex="-1">重复数据 <a class="header-anchor" href="#重复数据" aria-label="Permalink to &quot;重复数据&quot;">​</a></h4><p>由于前期时间确实比较紧张，准备不足，导致程序存在一些问题，经过排查发现，在导入数据的时候没有判断数据的唯一性，导致数据重复。这个算是一个bug，目前已经修复了。</p><h4 id="数据延迟" tabindex="-1">数据延迟 <a class="header-anchor" href="#数据延迟" aria-label="Permalink to &quot;数据延迟&quot;">​</a></h4><p>由于高峰期存在接口10秒都没有提交成功的情况，后来发现mysql事务中的查询存在比较大的耗时，经过调整添加索引修改查询条件，不进行全表扫描，目前观察不存在事务高峰期数据并发导致Mysql数据库CPU拉满的情况。</p><h4 id="日志处理" tabindex="-1">日志处理 <a class="header-anchor" href="#日志处理" aria-label="Permalink to &quot;日志处理&quot;">​</a></h4><p>应用中存在记录日志文件过大，并发量大的时候，导致频繁插入，而且文件越大插入速度必然很慢，这里做了文件大小限制，将大小设置未10M，很小了，速度非常快。并且在应用中对日志类型也就是写入日志的频次进行 修改，没有必要的日志进行了移除。</p><h4 id="用户身份" tabindex="-1">用户身份 <a class="header-anchor" href="#用户身份" aria-label="Permalink to &quot;用户身份&quot;">​</a></h4><p>通过调试发现，每次接口调用，用户身份信息都会重新获取，而且要请求mysql，这个看了一下并不是那么容易处理，暂时还没解决。这里可以进行缓存处理，但是发现有一点复杂，后面有时候肯定还是要处理的。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>最近刚好在重装自己的办公电脑，以及个人华为云服务器，</p><ul><li>linux磁盘挂载问题</li><li>mysql数据备份问题</li><li>服务器扩容前的处理事项、应用备份、以及相关配置文件</li><li>服务器扩容后的检查工作、磁盘状态、应用、数据库、redis等正常使用</li></ul>`,30)]))}const b=e(t,[["render",s]]);export{u as __pageData,b as default};
